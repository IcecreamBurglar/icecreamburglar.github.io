<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>http://moolick.dev/</id>
	<title>Moolick's Writings</title>
	<link rel="self" href="http://moolick.dev/" />
	<rights>2020</rights>
	<updated>2020-01-21T20:40:34Z</updated>
	<logo>http://moolick.dev/banner.jpg</logo>
	<subtitle>Moolick's Writings</subtitle>
	<entry>
		<id>http://moolick.dev/blog/using-cake</id>
		<title>Using CAKE To Organize Dependencies</title>
		<link href="http://moolick.dev/blog/using-cake" />
		<link rel="enclosure" type="image" href="http://moolick.dev/banner.jpg" />
		<updated>2020-01-21T00:00:00Z</updated>
		<content>&lt;h1 id="use-case"&gt;Use-case&lt;/h1&gt;
&lt;p&gt;During the &lt;em&gt;Great Refactoring&lt;/em&gt; of Wallapp, I encountered a situation that was going to get tedious to solve by-hand.&lt;/p&gt;
&lt;p&gt;I separated out the Engine from the UI into two distinct projects (Engine and App respectively).
When launched, the UI starts the Engine process, and they communicate via an IPC channel through Standard In/Out.&lt;/p&gt;
&lt;p&gt;That part's fine, it's just some context. The issue is copying the Engine's output to the App's output location so the App can actually resolve the Engine's executable.&lt;/p&gt;
&lt;p&gt;I initially solved that via a simple Post-Build script from within visual studio that copied the output from one to the other. Voila, problem solved. Another way I could have solved it, would have been by simply changing the Engine's output directory to that of the App's. But I didn't like doing it that way. I'm picky I suppose.&lt;/p&gt;
&lt;p&gt;Though there was an annoyance. Between both projects, as it obviously turned out, we had a several dependencies that were needed in the program's working directory to resolve.&lt;/p&gt;
&lt;p&gt;That was a mess. A messy-mess, even.&lt;/p&gt;
&lt;p&gt;Instead of extending my build script, I opted to resolve this by finally learning CAKE.&lt;/p&gt;
&lt;h1 id="c-make-enters-the-room"&gt;[C# MAKE ENTERS THE ROOM]&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="https://cakebuild.net/"&gt;Cake&lt;/a&gt;&lt;/em&gt;, or &lt;em&gt;c# make&lt;/em&gt;, is a build automation tool using a familiar c# syntax.
A quick google and some samples later, and it looks like Cake provides an easy, relatively painless way to not only run builds, but &lt;em&gt;clean directories&lt;/em&gt;, run &lt;em&gt;unit tests&lt;/em&gt;, &lt;em&gt;compress files&lt;/em&gt;, build &lt;em&gt;NuGet packages&lt;/em&gt;, alter &lt;em&gt;version numbers&lt;/em&gt; within a project's AssemblyInfo, and of course, the thing we're interested in, &lt;em&gt;copying/moving files and directories&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;As a matter of fact, it looks like cake utilizes Roslyn's Scripting API. &lt;br /&gt;
Though I've not actually looked into it, so I'm not certain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="quick-sample"&gt;Quick Sample&lt;/h2&gt;
&lt;p&gt;Here's a simple example of a basic Cake script I've taken from the official repo and slightly tweaked.&lt;br /&gt;
&lt;em&gt;Source: &lt;a href="https://github.com/cake-build/example/blob/master/build.cake"&gt;https://github.com/cake-build/example/blob/master/build.cake&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;// Get the task the user wants to perform from the command line arguments. We'll use a default value of &amp;quot;Default&amp;quot; should the user not specify anything.
var target = Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;);

// Get the project configuration the user wants to perform the task on from the command line.
var configuration = Argument(&amp;quot;configuration&amp;quot;, &amp;quot;Release&amp;quot;);

// Define the build directory so we don't have to type this out everywhere. This makes use of Cake's IO operations and types.
var buildDirectory = Directory(&amp;quot;./src/Example/bin&amp;quot;) + Directory(configuration);


// Define our &amp;quot;Clean&amp;quot; task. This task will clean the build directory. Notice the lambda that gets invoked when the task is run is denoted by the &amp;quot;Does&amp;quot; function.
Task(&amp;quot;Clean&amp;quot;)
    .Does(() =&amp;gt;
{
    // Log some stuff to the output window.
    Information(&amp;quot;Cleaning '{buildDirectory}'...&amp;quot;);
    CleanDirectory(buildDirectory);
});


// Create a task that restores nuget package references.
// Notice that this task is &amp;quot;dependent on&amp;quot; the clean task. This works pretty much as expected - it'll execute the &amp;quot;Clean&amp;quot; task prior to actually invoking this task.
Task(&amp;quot;Restore-NuGet-Packages&amp;quot;)
    .IsDependentOn(&amp;quot;Clean&amp;quot;)
    .Does(() =&amp;gt;
{
    NuGetRestore(&amp;quot;./src/Example.sln&amp;quot;);
});


// Create a task that will invoke MSBuild to actually build our prject. Notice that this task first restores nuget packages, which in turn cleans the build directory.
Task(&amp;quot;Build&amp;quot;)
    .IsDependentOn(&amp;quot;Restore-NuGet-Packages&amp;quot;)
    .Does(() =&amp;gt;
{
    // Log some stuff.
    Information(&amp;quot;Building...&amp;quot;)
    Debug($&amp;quot;Configuration {configuration}.&amp;quot;);
    
    // The settings paramater either accepts an instance of MSBuildSettings, or an Action&amp;lt;MSBuildSettings&amp;gt; as seen here.
    MSBuild(&amp;quot;./src/Example.sln&amp;quot;, settings =&amp;gt;
        settings.SetConfiguration(configuration));
});


// Execute the task the user specified.
RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we are also able to write to a log as we go.
More info on this in the relevant docs, here: &lt;a href="https://cakebuild.net/dsl/logging/"&gt;https://cakebuild.net/dsl/logging/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="execute-the-cake-script"&gt;Execute The Cake Script&lt;/h2&gt;
&lt;p&gt;To actually execute the cake script, the bootstrapper must be run. The bootstrapper script is a small powershell script which, according to the &lt;a href="https://cakebuild.net/docs/tutorials/getting-started"&gt;docs&lt;/a&gt;, simply ensures the Cake runtime is downloaded and accessible.
It then invokes the cake command line app which executes the build script.&lt;/p&gt;
&lt;p&gt;To start from scratch, use PowerShell to download the bootstrapping script from the Cake team. Execute the following command in powershell from the directory your cake build script is located:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ps"&gt;Invoke-WebRequest https://cakebuild.net/download/bootstrapper/windows -OutFile build.ps1
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Incidentally, powershell is also something I want to get more proficient in. But interestingly enough, even the static site generator I'm using (&lt;a href="https://wyam.io/"&gt;https://wyam.io/&lt;/a&gt;) takes advantage of cake and the accompanying powershell bootstrapper. I've just been mindlessly invoking the script without knowing what's going on up until this point.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Then to run your build script, simply execute &amp;quot;./build.ps1 [arguments]&amp;quot; from the same directory.&lt;/p&gt;
&lt;p&gt;All this information is available in the CakeBuild docs on their site at &lt;a href="https://cakebuild.net/docs/"&gt;https://cakebuild.net/docs/&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="our-cake-script-and-post-build-events"&gt;Our Cake Script And Post-Build Events&lt;/h1&gt;
&lt;p&gt;With some formalities out of the way, I think we're ready to see how exactly we can leverage the CakeBuild system to automatically copy output files from one project, to another.
Then finally, after that move, we'll copy &lt;strong&gt;all&lt;/strong&gt; dependency libraries to a &amp;quot;lib/&amp;quot; directory in the app's output directory.&lt;/p&gt;
&lt;p&gt;I'm literally going to just copy+paste the WallApp cake build script in its current state.&lt;/p&gt;
&lt;h2 id="cake-build-script"&gt;Cake Build Script&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;var target = Argument(&amp;quot;target&amp;quot;, &amp;quot;Build&amp;quot;);
var configuration = Argument(&amp;quot;configuration&amp;quot;, &amp;quot;Debug&amp;quot;);
var platform = Argument(&amp;quot;platform&amp;quot;, &amp;quot;Automatic&amp;quot;);

var solution = &amp;quot;./WallApp.sln&amp;quot;;

// Set MSBuildSettings configuration to our input arguments.
public void SetConfiguration(MSBuildSettings settings)
{
    settings.Configuration = configuration;
    settings.MSBuildPlatform = (MSBuildPlatform)Enum.Parse(typeof(MSBuildPlatform), platform);
}

// Nuget restore.
Task(&amp;quot;Restore&amp;quot;).Does(() =&amp;gt; NuGetRestore(solution));

// Rebuild (Clean -&amp;gt; Build).
Task(&amp;quot;Rebuild&amp;quot;).IsDependentOn(&amp;quot;Clean&amp;quot;).IsDependentOn(&amp;quot;Build&amp;quot;);

// Build the project, copying the output of the Engine to the output directory of the App.
Task(&amp;quot;Build&amp;quot;)
    .IsDependentOn(&amp;quot;Restore&amp;quot;)
    .Does(() =&amp;gt;
{
    MSBuild(solution, SetConfiguration);
    RunTarget(&amp;quot;CopyOutput&amp;quot;);
});


// Clean output directories.
Task(&amp;quot;Clean&amp;quot;)
    .Does(() =&amp;gt;
{
    var directories = new string[]
    {
        string.Format(&amp;quot;./Engine/obj/{0}&amp;quot;, configuration),
        string.Format(&amp;quot;./Engine/bin/{0}&amp;quot;, configuration),
        string.Format(&amp;quot;./WallApp.App/obj/{0}&amp;quot;, configuration),
        string.Format(&amp;quot;./WallApp.App/bin/{0}&amp;quot;, configuration)
    };

    foreach (var item in directories)
    {
        Information($&amp;quot;Cleaning '{item}'...&amp;quot;);
        CleanDirectories(item);
    }

    Information($&amp;quot;Cleaned {directories.Length} directories&amp;quot;);
});

// Copy the output from Bridge to App's output directory.
Task(&amp;quot;CopyOutput&amp;quot;)
    .Does(() =&amp;gt;
{
    var engineDirectory = $&amp;quot;./Engine/bin/{configuration}/&amp;quot;;
    var appDirectory = $&amp;quot;./WallApp.App/bin/{configuration}/&amp;quot;;
    var libDirectory = $&amp;quot;{appDirectory}lib/&amp;quot;;
    var modulesDirectory = $&amp;quot;./modules/&amp;quot;;

    // Copy Engine's output to App output.
    Information($&amp;quot;Copying files from '{engineDirectory}' to '{appDirectory}'...&amp;quot;);
    CopyFiles(engineDirectory + &amp;quot;*&amp;quot;, appDirectory);

    // Create subfolder for third-party libraries.
    Information($&amp;quot;Recreating '{libDirectory}'...&amp;quot;);
    if(DirectoryExists(libDirectory))
    {
        DeleteDirectory(libDirectory, new DeleteDirectorySettings() { Recursive = true, Force = true });
    }
    CreateDirectory(libDirectory);

    // Copy third-party libraries to sub-folder.
    var files = System.IO.Directory.GetFiles(MakeAbsolute(DirectoryPath.FromString(appDirectory)).ToString());
    Information(&amp;quot;\r\nCopying libs======================&amp;quot;);
    foreach(var file in files)
    {
        // Don't copy *our* files.
        if(file.EndsWith(&amp;quot;WallApp.exe&amp;quot;)
            || file.EndsWith(&amp;quot;WallApp.pdb&amp;quot;)
            || file.EndsWith(&amp;quot;WallApp.exe.config&amp;quot;))
        {
            continue;
        }
        if(file.EndsWith(&amp;quot;Engine.exe&amp;quot;)
            || file.EndsWith(&amp;quot;Engine.pdb&amp;quot;)
            || file.EndsWith(&amp;quot;Engine.exe.config&amp;quot;))
        {
            continue;
        }

        
        var withoutExtension = System.IO.Path.GetFileNameWithoutExtension(file);
        var name = System.IO.Path.GetFileName(file);

        // If the file is a dll or pdb, move it to the subfolder.
        if(file.EndsWith(&amp;quot;.dll&amp;quot;)
            || file.EndsWith(&amp;quot;.pdb&amp;quot;))
        {
            Information($&amp;quot;Moving '{name}' to lib directory...&amp;quot;);
            MoveFileToDirectory(file, libDirectory);
        }

        // If the file is an xml and also there is an accompanying library, then
        // this xml must be docs for the library -- move it.
        if(file.EndsWith(&amp;quot;.xml&amp;quot;)
            &amp;amp;&amp;amp; files.Any((f) =&amp;gt; f.EndsWith(withoutExtension + &amp;quot;.dll&amp;quot;)))
        {
            Information($&amp;quot;Moving '{name}' to lib directory...&amp;quot;);
            MoveFileToDirectory(file, libDirectory);
        }
    }
    Information(&amp;quot;Finished copying libs======================\r\n&amp;quot;);

    // Copy the modules folder in the root of the solution to the modules sub directory.
    Information($&amp;quot;Copying '{modulesDirectory}' to '{appDirectory}modules/'...&amp;quot;);
    CopyDirectory(modulesDirectory, appDirectory + &amp;quot;modules/&amp;quot;);
});


RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whew! That's a little bit more than the previous sample. The interesting bits are in the &lt;code&gt;CopyOutput&lt;/code&gt; task.&lt;/p&gt;
&lt;p&gt;Of particular importance, are the &lt;code&gt;CopyFiles&lt;/code&gt;, &lt;code&gt;DirectoryExists&lt;/code&gt;, &lt;code&gt;MoveFileToDirectory&lt;/code&gt;, and &lt;code&gt;CopyDirectory&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;Additionally, I through together some logic to distinguish the difference between xml documentations for code and actual xml files the program needs to function. &lt;strong&gt;It won't move xml files that don't have accompanying dlls to the subfolder.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The order of operations here is something like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Copy Engine output to App output (where we'll actually launch our program from)&lt;/li&gt;
&lt;li&gt;Create the &amp;quot;lib/&amp;quot; subfolder, first deleting it and its contents if it already exists&lt;/li&gt;
&lt;li&gt;Iterate over all files in the output folder and move them to the &amp;quot;lib/&amp;quot; directory as appropriate.&lt;/li&gt;
&lt;li&gt;Finally, move extension modules from the solution directory to the app's output directory.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="post-build-script"&gt;Post-Build Script&lt;/h2&gt;
&lt;p&gt;The is all well and good. But what if we want to perform our copy whenever we &lt;em&gt;do&lt;/em&gt; happen to build from within visual studio?
MSBuild allows you to write both Pre-and-Post build event .bat scripts that it'll execute when appropriate during the build process.
And this is what we'll take advantage of.
To access what we're interested in, the Post Build script, navigate to the project's properties from within Visual Studio and it'll be one of the tabs on the left pane.&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/blog/using-cake/build-events-page.PNG" class="img-fluid" alt="build-events-page" /&gt;&lt;/p&gt;
&lt;p&gt;In the &amp;quot;Post-build event command line:&amp;quot; box, we'll use the following snippet: &lt;code&gt;cd &amp;quot;$(SolutionDir)&amp;quot; &amp;amp;&amp;amp; powershell -file &amp;quot;build.ps1&amp;quot; -target CopyOutput&lt;/code&gt;.
This snippet changes the working directory from the project's directory to the solution's directory (where our build script &lt;em&gt;should&lt;/em&gt; be. If you're isn't here, change this bit to wherever your build script is located). Then it launches powershell passing in the build.ps1 script as an argument, as well as the target-task we want cake to execute.&lt;/p&gt;
&lt;h1 id="and.thats-it"&gt;And.. That's it...&lt;/h1&gt;
&lt;p&gt;That's literally all there is to it.
Cake is something I've wanted to learn for a couple years now, but never really needed it before now. And truthfully, I probably could have achieved what I'm using for in WallApp with just a powershell/bat script.&lt;/p&gt;
&lt;p&gt;But I wanted to sieze this opportunity to learn finally learn Cake, and I was not dissappointed. It seems to be one of those things that's almost deceptively simple.&lt;/p&gt;
&lt;p&gt;After reading about Cake and looking at examples, I finally just jumped right into writing it all up myself and found that it really wasn't as complicated as I was originally making it out to be.&lt;/p&gt;
&lt;p&gt;Hopefully you've drawn something from this, if not, maybe just start from the official Cake docs and dive right in.&lt;/p&gt;
&lt;p&gt;You can always see the cake script I use in WallApp on the project's repository at &lt;a href="https://github.com/moolicc/WallApp"&gt;https://github.com/moolicc/WallApp&lt;/a&gt;. Currently, the dev branch is the only place you'll find the relevant information.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;During the &lt;em&gt;Great Refactoring&lt;/em&gt; of Wallapp, I encountered a situation that was going to get tedious to solve by-hand.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://moolick.dev/blog/entity-component-system-part4</id>
		<title>Creating an Entity Component System in c# - Revisit</title>
		<link href="http://moolick.dev/blog/entity-component-system-part4" />
		<link rel="enclosure" type="image" href="http://moolick.dev/banner.jpg" />
		<updated>2019-01-12T00:00:00Z</updated>
		<content>&lt;h1 id="revisit"&gt;Revisit&lt;/h1&gt;
&lt;p&gt;Clear your mind of what you've read here from previous posts in this overly long-winded series.
Shortly after I wrote the last post, I realized that some of the stuff I said was not entirely correct.
Specifically, we were still stacking up the HEAP allocations because&lt;/p&gt;
&lt;ol type="A"&gt;
&lt;li&gt;Value-type implementations of interfaces are boxed&lt;/li&gt;
&lt;li&gt;an &lt;code&gt;int&lt;/code&gt; stored as an &lt;code&gt;object&lt;/code&gt; is boxed&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, We'll still follow the same concept for data locality. We'll use a 1-dimensional array to store entities via their IDs and components.
We'll use the fore-front of our array to index into entities' components.
A key difference, is that this time, our list's declaration looks like &lt;code&gt;List&amp;lt;EntityItem&amp;gt; _entities;&lt;/code&gt;.
This brings us to our first point.&lt;/p&gt;
&lt;h2 id="terminology-ill-try-to-follow"&gt;Terminology I'll (try) to follow&lt;/h2&gt;
&lt;p&gt;Let's just go over the wording I'll use to make sure everything I type here is crystal-clear.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An &lt;em&gt;entity index&lt;/em&gt; or &lt;em&gt;entity pointer&lt;/em&gt; is the item within our entities list that holds an index to the beginning of an entity's component list&lt;/li&gt;
&lt;li&gt;An &lt;em&gt;entity ID&lt;/em&gt; is an index that corresponds to an entity index within the entities list&lt;/li&gt;
&lt;li&gt;An &lt;em&gt;entity&lt;/em&gt; is the sub-list of components within our entities list that represents an entity in the caller's game or simulation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here's a little something I drew-up to hopefully help visualize. It also might be too hard to see, I'm one of the unlucky folks who doesn't have 20 cameras
on my phone to take clear pictures.
Where &lt;em&gt;E&lt;/em&gt; is our list of entities.&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/blog/entity-component-system-part4/ecs.jpg" class="img-fluid" alt="rough-ecs" /&gt;&lt;/p&gt;
&lt;p&gt;Note that the code itself might not fully conform to these terms. Hopefully, it'll be concise enough to not even matter though.&lt;/p&gt;
&lt;h1 id="storing-numerical-ids-without-boxing"&gt;Storing Numerical IDs Without Boxing&lt;/h1&gt;
&lt;p&gt;OK, so the title of this paragraph is a tad misleading. We'll in actuality be abstracting both entity indices and components, but this time we'll do so
via our own struct, which I've aptly named &lt;code&gt;EntityItem&lt;/code&gt;. However at least here, we know our 32-bit integer ID won't be stored in the HEAP.&lt;/p&gt;
&lt;p&gt;An instance of an EntityItem either represents an entity's index or an actual concrete component.
The EntityItem type contains most importantly, two fields. One of type ComponentBase (named &amp;quot;Component&amp;quot;), and another of type int (named &amp;quot;EntityIndex&amp;quot;). We've also got a bool for IsAlive to determine if the entity has been removed or not. And finally, I've thrown in a handy bool, &lt;em&gt;IsComponent&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;It's probably worth noting that all of these are literally &lt;strong&gt;fields&lt;/strong&gt; and not &lt;strong&gt;properties.&lt;/strong&gt;. The purpose of this
is that fields are stored as &lt;em&gt;references&lt;/em&gt; and properties behave more like &lt;em&gt;values&lt;/em&gt; (properties are a tad more complicated than that as they really
just wrap around private fields themselves anyway). This is important because if our Component field was accessed like a value, then changes made to
the component in the code that consumes are ECS wouldn't modify the actual component we're storing, but in essence a copy of it.
Additionally, I've thrown in a couple of constructor overloads to make instantiating this struct more convinient.
&lt;code&gt;public EntityItem(int entityIndex)&lt;/code&gt; and &lt;code&gt;public EntityItem(ComponentBase component)&lt;/code&gt;. Though both of these just call into an
private constructor that looks like &lt;code&gt;private EntityItem(int entityIndex, ComponentBase component)&lt;/code&gt; that sets everything up for us.&lt;/p&gt;
&lt;h1 id="the-entity-manager"&gt;The Entity Manager&lt;/h1&gt;
&lt;p&gt;Our entity manager is very similar to the previous idea, having a single list containing components bound to numerical entity IDs.
Also like I mentioned in the previous post, we'll set our list's initial capacity to go ahead and have its internal array allocate a chunk of memory.
If we don't do this, then as we add to the list it'll contantly have to resize its underlying array.
In fact, the contructor's body is only three lines, and is responsible only for creating a list of systems to manager, our entity list,
and setting our entity ID counter to 0. It looks a little something like this&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public EntityManager(int entityCount)
{
  Systems = new List&amp;lt;SystemBase&amp;gt;();
  _entities = new List&amp;lt;EntityItem&amp;gt;(entityCount * COMPONENTS_PER_ENTITY);
  _deadIds = new Queue&amp;lt;int&amp;gt;(entityCount);
  _nextId = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;COMPONENTS_PER_ENTITY&lt;/code&gt; is merely an estimated number of components every entity will contain. At the time of writing this, it's set to 6.&lt;/p&gt;
&lt;h2 id="the-code"&gt;The Code&lt;/h2&gt;
&lt;p&gt;I'll try to keep some of my breath in my lungs and only mention the interesting/important bits in here, but I'll leave a link to the code further on.
Certainly most of the code is boilerplate, and there's a lot of duplication because within the (dare I call them) algorithms I use in each operation
(remove, add, find, etc) there are small changes on singular lines to optimize for that specific operation we're performing at the time.&lt;/p&gt;
&lt;p&gt;OK, let's begin.&lt;/p&gt;
&lt;h3 id="private-utilities"&gt;Private utilities&lt;/h3&gt;
&lt;p&gt;One thing we'll be doing a lot of is identifying if an &lt;em&gt;EntityItem&lt;/em&gt; at a given index within &lt;em&gt;_entites&lt;/em&gt; is an entity or a component.
That being said, we can save some time and ware on our fingers if we use a helper function, like the following&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private bool IsEntityPointer(int entityId, out EntityItem entityItem)
{
  entityItem = EntityItem.Empty;
  if (entityId &amp;lt; 0
      || entityId &amp;gt;= _entities.Count
      || _entities[entityId].IsComponent)
  {
      return false;
  }

  entityItem = _entities[entityId];
  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What we're doing here, is merely checking the given index to ensure it is within our &lt;em&gt;_entites&lt;/em&gt; bounds and then checking the item at that index
to see if it's an entity index or entity. We also go ahead and return the entityitem (assuming it was an entity index) in the form of our &lt;code&gt;out EntityItem entityItem&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Furthermore, we'll be performing quite a few operations upon entity pointers, so let's go ahead and create a helper function to aid with that.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private void IterateEntityPointers(int startingId, Action&amp;lt;int, EntityItem&amp;gt; action)
{
  for (int i = startingId; i &amp;lt; _entities.Count &amp;amp;&amp;amp; IsEntityPointer(i, out var item); i++)
  {
      action(i, item);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will allow us to loop over entity pointers without throwing the exact same for loop everywhere. It's important to note
that this loop stops iterating as soon as we hit an entity's component list.&lt;/p&gt;
&lt;p&gt;I think this is best explained through an example of use, so here goes&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;IterateEntityPointers(0, (i, e) =&amp;gt;
  {
    Console.WriteLine($&amp;quot;Entity at ID {i}: {e}&amp;quot;);
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, we also have one to iterate over an entire entity.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private void IterateEntity(EntityItem entity, int entityId, Func&amp;lt;int, EntityItem, bool&amp;gt; action)
{
  int endIndex = _entities.Count;
  if(IsEntityPointer(entityId + 1, out var nextEnt))
  {
    endIndex = nextEnt.EntityIndex;
  }
  for (int i = entity.EntityIndex; i &amp;lt; endIndex; i++)
  {
    if(action(i, _entities[i]))
    {
      break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also throw in the necessary logic to ensure we don't overflow into another entity (&lt;em&gt;see: endIndex&lt;/em&gt;).
This one is a tad bit different than the former in that it allows the calling code to break out of the loop early if &lt;code&gt;action&lt;/code&gt; returns &lt;em&gt;true&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="public-appearances"&gt;Public appearances&lt;/h3&gt;
&lt;p&gt;Now that we've got all of our little helpers out of the way, let's go ahead and cover the 6 basic operations a caller might do&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Creating an entity&lt;/li&gt;
&lt;li&gt;Destroying an entity&lt;/li&gt;
&lt;li&gt;Adding a component to an entity&lt;/li&gt;
&lt;li&gt;Removing a component from an entity&lt;/li&gt;
&lt;li&gt;Checking for the existance of a component within an entity&lt;/li&gt;
&lt;li&gt;Iterating an entity's components&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Without too much fanfaire, I'm just going to give you a good shove off the proverbial diving board.&lt;/p&gt;
&lt;h4 id="creating-an-entity"&gt;Creating an entity&lt;/h4&gt;
&lt;p&gt;First, it's rather important to have to ability to add an entity to our thing here.
We'll do that via a fancy, albeit blandly named &lt;em&gt;CreateEntity&lt;/em&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public int CreateEntity()
{
  //Check for a recyclable ID first.
  if(_deadIds.Count != 0)
  {
    int id = _deadIds.Dequeue();
    var ent = _entities[id];
    ent.IsAlive = true;
    _entities[id] = ent;
    return id;
  }

  //Increment each previous entity's starting index.
  for (int i = 0; i &amp;lt; _nextId; i++)
  {
    var ent = _entities[i];
    ent.EntityIndex++;
    _entities[i] = ent;
  }
  //Add this entity in with a starting index pointing to the end
  //of the array.
  _entities.Insert(_nextId, new EntityItem(_entities.Count + 1));
  return _nextId++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The comments hopefully make this snippet self-explanatory, but I'll show you the highlights anyway.
First of all, we quite simply check for dead entities to revive for use. But if there's not an entity we can breath life into again, we have
to take a few precautions to add a new entity pointer.
So if we're going to be adding in an entity pointer &lt;strong&gt;after&lt;/strong&gt; other entity pointers but &lt;strong&gt;before&lt;/strong&gt; entities actually begin then it's pretty
important to inform the previous entity pointers that we're going to do this. Otherwise, their indices won't be correct as our list will grow
without them being aware. &lt;em&gt;We'll unfortunately have to do this until the machine learning train creates self-aware objects.&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="destroying-an-entity"&gt;Destroying an entity&lt;/h4&gt;
&lt;p&gt;Next up, we should take a look at the case where a caller might be a monster and desire the destruction of an entity.
So I guess we should also include a method of the removal of entities.&lt;/p&gt;
&lt;aside&gt;Remember, Simba&lt;/aside&gt;
&lt;p&gt;\&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;: I actually forgot to implement this until writing this post. Before this time, entities overpopulated the world, causing mass-chaos.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public void DestroyEntity(int entityId)
{
  //Sanity check to make sure the passed entityId is valid.
  if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
  {
    throw new InvalidOperationException(&amp;quot;The specified entity does not exist.&amp;quot;);
  }

  //Find the end index of the entity's component list.
  int endIndex = _entities.Count;
  if(IsEntityPointer(entityId + 1, out var nextEntityItem))
  {
    endIndex = nextEntityItem.EntityIndex;
  }

  //Hold the actual number of components this entity owns.
  int componentCount = endIndex - entItem.EntityIndex;

  //Decrement all following entity pointers to account for the removal
  //of the components from the current entity.
  IterateEntityPointers(entityId + 1, (i, e) =&amp;gt;
    {
      e.EntityIndex -= componentCount;
      _entities[i] = e;
    });

  //Remove the entity and mark the pointer as dead.
  _entities.RemoveRange(entItem.EntityIndex, componentCount);
  entItem.IsAlive = false;
  _entities[entityId] = entItem;
  _deadIds.Enqueue(entityId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK, that one is a tad bit longer than we're used to. But we'll be fine if we break it down.
First, as the comment states, we perform a check to ensure the entity is currently alive and well.
We'll see checks like these throughout, so I'll probably not explain them going on.&lt;/p&gt;
&lt;p&gt;The next thing we do is find out where this entity ends, we do this to find the count of components this entity contains.
We then inform all following entities about the removal of our components. If we don't do this, other entities won't know
that the indices in the list are changing and we could (and would) have descprepancies.&lt;/p&gt;
&lt;p&gt;Finally, we simply remove the components and mark the entity ID as dead.&lt;/p&gt;
&lt;h4 id="adding-a-component-to-an-entity"&gt;Adding a component to an entity&lt;/h4&gt;
&lt;p&gt;Now that we know how to add and remove entire entities, what's say we go ahead and look at the code we use to add a component
to an entity. It's worth noting that this doesn't &lt;em&gt;add&lt;/em&gt; a component to the end of an entity, but rather this will &lt;em&gt;push&lt;/em&gt; a component
into the first position of an entity.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public void PushComponent(int entityId, ComponentBase component)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&amp;quot;The specified entity does not exist.&amp;quot;);
    }

    //If there are entities after this one, increment their starting indices.
    IterateEntityPointers(entityId + 1, (i, e) =&amp;gt;
    {
        e.EntityIndex++;
        _entities[i] = e;
    });

    //Add the component under the entity's area.
    component.OwnerId = entityId;
    _entities.Insert(entItem.EntityIndex, new EntityItem(component));

    //Notify the systems that an entity has been modified.
    RefreshSystems(entityId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code should be fairly self-explanatory.
The first interesting thing we do is notify following entity pointers that they should increment by one to account for the new component going in
ahead of their entities.
Second, we set the component's owner and add it in.
Finally, we inform all systems that an entity has been modified.&lt;/p&gt;
&lt;h4 id="removing-a-component"&gt;Removing a component&lt;/h4&gt;
&lt;p&gt;The removal of a component is exactly the same as the addition of a component, but of course in reverse.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public void RemoveComponent(int entityId, ComponentBase component)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&amp;quot;The specified entity does not exist.&amp;quot;);
    }

    //Find the index of the component.
    int componentIndex = -1;
    IterateEntity(entItem, entityId, (i, c) =&amp;gt;
    {
        if(c.Component == component)
        {
            c.Component.OwnerId = -1;
            componentIndex = i;
            return true;
        }
        return false;
    });
    
    //Sanity check to make sure the component exists.
    if(componentIndex == -1)
    {
        throw new InvalidOperationException(&amp;quot;The specified entity does not contain that component.&amp;quot;);
    }

    //If there are entities after this one, decrement their starting indices.
    IterateEntityPointers(entityId + 1, (i, e) =&amp;gt;
    {
        e.EntityIndex--;
        _entities[i] = e;
    });

    //Remove the component
    _entities.RemoveAt(componentIndex);

    //Notify the systems that an entity has been modified.
    RefreshSystems(entityId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing worth mentioning that we're doing here is finding out where the component actually lives in the larget _entities list.
While we're at that search, we go ahead and set the component's owner to -1 to signify that it's no longer loved enough to have an owner.&lt;/p&gt;
&lt;p&gt;The next thing we do - and this is a bit complicated so please, try to stay with me - the next thing we do is an error check to
ensure that the component was actually found.&lt;/p&gt;
&lt;p&gt;Finally, we once again inform other entity pointers about this change, remove the component, and notify systems there's been a modification
to our entity.&lt;/p&gt;
&lt;h4 id="checking-for-the-extistance-of-a-component"&gt;Checking for the extistance of a component&lt;/h4&gt;
&lt;p&gt;Honestly I'm not even sure I can fluff this up a great deal. It's really quite simple and the code is mostly self-explanatory.
But I'd say I'm doing a fantastic job of jamming as many characters as I can into this section before even showing you the code.&lt;/p&gt;
&lt;p&gt;Without further ado, I will not copy + past the code into this document for your viewing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public bool ContainsComponent(int entityId, ComponentBase component)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&amp;quot;The specified entity does not exist.&amp;quot;);
    }

    //Check if the component exists.
    bool foundComponent = false;
    IterateEntity(entItem, entityId, (i, c) =&amp;gt;
    {
        if (c.Component == component)
        {
            foundComponent = true;
            //return true to inform IterateEntity to stop iterating.
            return true;
        }
        return false;
    });

    //Return the results.
    return foundComponent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="iterating-over-an-entitys-components"&gt;Iterating over an entity's components&lt;/h4&gt;
&lt;p&gt;...I won't even try for this one...&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public IEnumerable&amp;lt;ComponentBase&amp;gt; GetComponents(int entityId)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&amp;quot;The specified entity does not exist.&amp;quot;);
    }

    //Iterate until necessary and yield return the components.
    int endIndex = _entities.Count;
    if (IsEntityPointer(entityId + 1, out var nextEnt))
    {
        endIndex = nextEnt.EntityIndex;
    }
    for (int i = entItem.EntityIndex; i &amp;lt; endIndex; i++)
    {
        yield return _entities[i].Component;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only thing here to note is the &lt;code&gt;yield&lt;/code&gt; statement. If you're not sure what that means, then honestly google it.
There are plenty of smarter people who are far better at explaining things than me that have written about it.
Besides, probably the best advice you can garner from the internet is actually how to google.&lt;/p&gt;
&lt;h3 id="other-code"&gt;Other code&lt;/h3&gt;
&lt;p&gt;There's plenty of other code you can poke around at in the github.
I've included plenty of overloads to make the life of a consumer of this API easy and painless.&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Whew! After nearly a year, I've finally gotten around to completing an ECS and writing about it.
The Entity Component System is a fantastic tool to have on your belt, and honestly it's a joy to work with.
Writing one up can be kind of boiler-plate, but I find it fun to try and make it unique and at least some-what performance friendly.&lt;/p&gt;
&lt;p&gt;I've thrown the full code up on my &lt;a href="https://github.com/jmikew/hourglass"&gt;github&lt;/a&gt;.
So please, go poke around, have some fun, and let me know how it goes!&lt;/p&gt;
</content>
		<summary>&lt;p&gt;Clear your mind of what you've read here from previous posts in this overly long-winded series.
Shortly after I wrote the last post, I realized that some of the stuff I said was not entirely correct.
Specifically, we were still stacking up the HEAP allocations because&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://moolick.dev/blog/entity-component-system-part3</id>
		<title>Creating an Entity Component System in c# - Part 3</title>
		<link href="http://moolick.dev/blog/entity-component-system-part3" />
		<link rel="enclosure" type="image" href="http://moolick.dev/banner.jpg" />
		<updated>2018-06-20T00:00:00Z</updated>
		<content>&lt;h1 id="the-entity-component-system"&gt;The Entity-Component-System&lt;/h1&gt;
&lt;p&gt;The &lt;em&gt;Entity Component System&lt;/em&gt; (We'll abbreviate it &lt;em&gt;ECS&lt;/em&gt; for the sake of brevity) is designed to break away coupling that is naturally introduced when taking advantage of object-oriented-programming.
It achieves this by preferring to create &lt;em&gt;entities&lt;/em&gt; with &lt;strong&gt;composition&lt;/strong&gt; rather than &lt;strong&gt;inheritance&lt;/strong&gt;.
It works by assigning various &lt;em&gt;Components&lt;/em&gt; to each &lt;em&gt;Entity&lt;/em&gt; - such that an entity is nothing more than a container for components - and then various &lt;em&gt;Systems&lt;/em&gt; to act on said components. This in turn, makes the code much easier to maintain and expand upon.&lt;/p&gt;
&lt;p&gt;Want to add hunger into a survival game?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: add a &lt;em&gt;HungerComponent&lt;/em&gt; and assign it to the entity that represents the player.&lt;/li&gt;
&lt;li&gt;Step 2: add a &lt;em&gt;HungerSystem&lt;/em&gt; which monitors the &lt;em&gt;HungerComponent&lt;/em&gt; and performs whatever actions are necessary and related to hunger. Maybe the system reaches out to a &lt;em&gt;HealthComponent&lt;/em&gt; and depletes health. I don't know.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The beauty of an ECS, in my opinion, is the separation of logic and data it entails. Data is placed in components and logic is placed in systems.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="horror-movie-set-to-change-the-world-the-optimizing"&gt;2018 Horror Movie Set to Change the World: &lt;em&gt;The Optimizing&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;Alright, alright. So initially we were going to explore the use of components defined in a DSL that resembled something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;Name(&amp;quot;BoundsComponent&amp;quot;)
Property&amp;lt;Rectangle&amp;gt;(&amp;quot;Bounds&amp;quot;)
Proxy(&amp;quot;X&amp;quot;, &amp;quot;Bounds.X&amp;quot;)
Proxy(&amp;quot;Y&amp;quot;, &amp;quot;Bounds.Y&amp;quot;)
Proxy(&amp;quot;Width&amp;quot;, &amp;quot;Bounds.Width&amp;quot;)
Proxy(&amp;quot;Height&amp;quot;, &amp;quot;Bounds.Height&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We were going to exploit both Roslyn and Reflection, to make the declaration of components both dynamic, and simplistic.&lt;/p&gt;
&lt;p&gt;But alas, I wrote-up a prototype and decided it didn't work out quite as nicely as I had hoped. Components turned-out to be cumbersome to work with in the actual game.&lt;/p&gt;
&lt;p&gt;So instead, let us  go forth, and optimize our current solution. For yea, right now, she is like unto an overweight beast.&lt;/p&gt;
&lt;p&gt;(&lt;strong&gt;NOTE:&lt;/strong&gt; &lt;em&gt;I had actually planned on writing a post about optimizing it after we got something working, it's just that the dynamic component thing was going to come first&lt;/em&gt;)&lt;/p&gt;
&lt;h1 id="the-plan"&gt;The Plan&lt;/h1&gt;
&lt;p&gt;So our primary performance concerns right now are basically summed-up into these  bullet points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary Search that the Dictionary uses&lt;/li&gt;
&lt;li&gt;Cache-misses&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So to alleviate these pains, &lt;del&gt;take Advil daily&lt;/del&gt; we'll start by turning the components into &lt;em&gt;stack-based&lt;/em&gt; &lt;strong&gt;value types&lt;/strong&gt; rather than the &lt;em&gt;heap-allocated&lt;/em&gt; &lt;strong&gt;reference types&lt;/strong&gt;. Perhaps in the future, I'll write something up about the difference between &lt;em&gt;value&lt;/em&gt; and &lt;em&gt;reference&lt;/em&gt; types, and the associated performance implications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update: UH-OH, it looks as though I've misspoken. Boxing an int as an object still incurs a heap-allocation.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Second, we shall knock-out both of our last two bullet points by replacing our original &lt;code&gt;Dictionary&amp;lt;ushort, List&amp;lt;Component&amp;gt;&amp;gt;&lt;/code&gt; with a fancy &lt;code&gt;List&amp;lt;object&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We'll use this list to store &lt;em&gt;all&lt;/em&gt; of our components for &lt;em&gt;all&lt;/em&gt; of our entities.
So the question may arise; &amp;quot;How does one actually distinguish which components belong to which entities?&amp;quot; The answer is actually fairly easy. We'll index where each entity's component list starts, and place this index at the start of our list. We'll access our index via &lt;em&gt;entity IDs&lt;/em&gt;, that themselves represent indices, but this time, into our index.&lt;/p&gt;
&lt;p&gt;Here's a &lt;strong&gt;very, very rough&lt;/strong&gt; depiction of how our collection will store our things for us.
&lt;img src="/assets/blog/entity-component-system-part3/roughecs.PNG" class="img-fluid" alt="rough-ecs" /&gt;&lt;/p&gt;
&lt;h2 id="why-not-use-a-list-of-some-custom-entity-class"&gt;Why Not Use A List of Some Custom 'Entity' Class?&lt;/h2&gt;
&lt;p&gt;There is actually a reason (or two) for this.&lt;/p&gt;
&lt;h3 id="the-first-being-cache-misses"&gt;The first being cache-misses.&lt;/h3&gt;
&lt;p&gt;More than likely, if you use a something like a &lt;code&gt;List&amp;lt;Entity&amp;gt;&lt;/code&gt;, each Entity instance will have a nested list of Components. So when you perform a search to find entities with specific components attached, you'd have to iterate via something akin to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;foreach(var entity in _entities)
{
  foreach(var component in entity.Components)
  {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically what happens is that the processor will try to cache whichever array it's currently working on. But we're alternating between &lt;em&gt;_entities&lt;/em&gt; and &lt;em&gt;entity.Components&lt;/em&gt;, so the processor will be switching between the two in its cache. This is somewhat inefficient and tiresome for our CPU.&lt;/p&gt;
&lt;h3 id="if-you-take-an-alternate-route-another-problem-subjective-arises"&gt;If you take an alternate route, another &amp;quot;problem&amp;quot; (subjective) arises.&lt;/h3&gt;
&lt;p&gt;Maybe to avoid lookups and cache-misses, you create concrete entity classes for each type of entity in your game, then each entity has public-facing members for each component it contains. So you'd have something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;class PlayerEntity : EntityBase
{
  public PositionComponent { get; private set; }
  public PhysicsComponent { get; private set; }
  public TextureComponent { get; private set; }
  public PlayerComponent { get; private set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only problem I have with this approach is that you lose some dynamic extensibility capabilities. The best you can do in terms of dynamic entity creation (ie, at runtime) is to use a DSL and have a transpiler translate your DSL data into concrete C# classes.&lt;/p&gt;
&lt;h1 id="the-implementation"&gt;The Implementation&lt;/h1&gt;
&lt;p&gt;So I'll just be going over the tid-bits I find interesting.
The code will be available on &lt;a href="https://github.com/moolicc"&gt;my github&lt;/a&gt; (in a repo called &amp;quot;hourglass&amp;quot;) at some point.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;The &lt;em&gt;Entity Component System&lt;/em&gt; (We'll abbreviate it &lt;em&gt;ECS&lt;/em&gt; for the sake of brevity) is designed to break away coupling that is naturally introduced when taking advantage of object-oriented-programming.
It achieves this by preferring to create &lt;em&gt;entities&lt;/em&gt; with &lt;strong&gt;composition&lt;/strong&gt; rather than &lt;strong&gt;inheritance&lt;/strong&gt;.
It works by assigning various &lt;em&gt;Components&lt;/em&gt; to each &lt;em&gt;Entity&lt;/em&gt; - such that an entity is nothing more than a container for components - and then various &lt;em&gt;Systems&lt;/em&gt; to act on said components. This in turn, makes the code much easier to maintain and expand upon.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://moolick.dev/blog/entity-component-system-part2</id>
		<title>Creating an Entity Component System in c# - Part 2</title>
		<link href="http://moolick.dev/blog/entity-component-system-part2" />
		<link rel="enclosure" type="image" href="http://moolick.dev/banner.jpg" />
		<updated>2018-05-13T00:00:00Z</updated>
		<content>&lt;h1 id="the-entity-component-system"&gt;The Entity-Component-System&lt;/h1&gt;
&lt;p&gt;The &lt;em&gt;Entity Component System&lt;/em&gt; (We'll abbreviate it &lt;em&gt;ECS&lt;/em&gt; for the sake of brevity) is designed to break away coupling that is naturally introduced when taking advantage of object-oriented-programming.
It achieves this by preferring to create &lt;em&gt;entities&lt;/em&gt; with &lt;strong&gt;composition&lt;/strong&gt; rather than &lt;strong&gt;inheritance&lt;/strong&gt;.
It works by assigning various &lt;em&gt;Components&lt;/em&gt; to each &lt;em&gt;Entity&lt;/em&gt; - such that an entity is nothing more than a container for components - and then various &lt;em&gt;Systems&lt;/em&gt; to act on said components. This in turn, makes the code much easier to maintain and expand upon.&lt;/p&gt;
&lt;p&gt;Want to add hunger into a survival game?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: add a &lt;em&gt;HungerComponent&lt;/em&gt; and assign it to the entity that represents the player.&lt;/li&gt;
&lt;li&gt;Step 2: add a &lt;em&gt;HungerSystem&lt;/em&gt; which monitors the &lt;em&gt;HungerComponent&lt;/em&gt; and performs whatever actions are necessary and related to hunger. Maybe the system reaches out to a &lt;em&gt;HealthComponent&lt;/em&gt; and depletes health. I don't know.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The beauty of an ECS, in my opinion, is the separation of logic and data it entails. Data is placed in components and logic is placed in systems.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="the-entity-manager"&gt;The Entity Manager&lt;/h1&gt;
&lt;p&gt;Hello, and welcome to the second episode of our 3-part journey. Today we will discuss the fairly straight-forward implementation of the EntityManager type.&lt;/p&gt;
&lt;p&gt;It really is nothing novel. I just didn't want to bog down the first post with all of the code from the EntityManager.cs source.&lt;/p&gt;
&lt;p&gt;Let's begin, shall we?&lt;/p&gt;
&lt;h1 id="class-declaration-and-fields"&gt;Class Declaration and Fields&lt;/h1&gt;
&lt;p&gt;So, first things must come first else they wouldn't be denoted &lt;em&gt;first things&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;My implementation is declared as &lt;code&gt;static&lt;/code&gt;, but you could easily not do that if that's not something you would like to do.&lt;/p&gt;
&lt;p&gt;Now onto the &lt;code&gt;fields&lt;/code&gt; part of this section.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static List&amp;lt;EntitySystem&amp;gt; Systems { get; private set; }

private static Dictionary&amp;lt;ushort, List&amp;lt;Component&amp;gt;&amp;gt; _entities;
private static Queue&amp;lt;ushort&amp;gt; _recycledIds;
private static ushort _lastId;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Those are all the fields we'll need to make this thing work.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="listentitysystem-systems"&gt;List&amp;lt;EntitySystem&amp;gt; Systems&lt;/h3&gt;
&lt;p&gt;First we have our &lt;code&gt;List&amp;lt;EntitySystem&amp;gt;&lt;/code&gt;. This keeps track of all the Systems that operate on Entities. It's necessary for the EntityManager to know about them so that we can issue notifications to each system.&lt;/p&gt;
&lt;p&gt;Then we have some private fields.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="dictionaryushort-listcomponent_entities"&gt;Dictionary&amp;lt;ushort, List&amp;lt;Component&amp;gt;&amp;gt; _entities&lt;/h3&gt;
&lt;p&gt;Let's talk about the &lt;em&gt;_entities&lt;/em&gt; field.
This field keeps up with each active entity in the scene. Each entity is assigned a unique, 16-bit ID and coupled with each component that makes up the entity.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I know it's ugly, but don't worry about the use of nested generics.&lt;/strong&gt; Specifically nesting the List&amp;lt;T&amp;gt; within the Dictionary&amp;lt;T&amp;gt;. What we'll do when we add new entries is actually use that &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; constructor that doesn't get a ton of love who's signature is something like &lt;code&gt;List&amp;lt;T&amp;gt;(int initialCapacity)&lt;/code&gt; to give us roughly the same performance as if we were to use a primitive array here.&lt;/p&gt;
&lt;p&gt;I'll explain all this in just a moment.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="queueushort_recycledids"&gt;Queue&amp;lt;ushort&amp;gt; _recycledIds&lt;/h3&gt;
&lt;p&gt;Aha! That brings us to our &lt;em&gt;Queue&lt;/em&gt; of &lt;em&gt;Recycled Entity IDs&lt;/em&gt;.
Each time we delete an entity, we'll store its ID in this queue.
Then when we create another entity, we'll pop an ID from this queue instead of leaving a &amp;quot;hole&amp;quot; in our otherwise continuous count of IDs. If &lt;em&gt;that&lt;/em&gt; doesn't sell the idea to you, then the re-use of IDs to avoid running out of available IDs (ahem, that's a big number, or 65535 to be exact) for as long as possible might.&lt;/p&gt;
&lt;p&gt;You should probably make this a &lt;code&gt;ConcurrentQueue&amp;lt;ushort&amp;gt;&lt;/code&gt; if you care about multithreading and stuff.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="ushort_lastid"&gt;ushort _lastId&lt;/h3&gt;
&lt;p&gt;This one is, well...
This one keeps track of the ID that belongs to the &lt;strong&gt;previously created entity&lt;/strong&gt;.
There's not much more to say about this little field though.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="a-touch-of-listts-internals"&gt;A Touch of List&amp;lt;T&amp;gt;'s Internals.&lt;/h2&gt;
&lt;p&gt;So I guess I promised I'd say something about this.&lt;/p&gt;
&lt;p&gt;It's pretty straightforward actually. So internally, the List, as you might have guessed, uses an Array of type T. It also has an index which points to the next empty position in the array that is used whenever you invoke the &lt;code&gt;List.Add&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Whenever this index exceeds the length of the array, a new array is created with an appropriate length - that is, &lt;code&gt;old length × 2&lt;/code&gt; - and an &lt;code&gt;Array.Copy&lt;/code&gt; operation is performed to move the contents of the old, short array into the new, longer array.&lt;/p&gt;
&lt;p&gt;So, by setting the initial capacity to a number we probably won't exceed (and if we do, it's OK), we're instructing the list to set the backing-array's initial length to a specific value. The array won't need to be resized unless we do happen to exceed the initial capacity value we throw at it.&lt;/p&gt;
&lt;p&gt;There is therefore, a minimal-to-no performance hit when using a &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; in this way, so long as you don't do anything more than adding/removing items.&lt;/p&gt;
&lt;p&gt;...LINQ operations are still slow... (But we'll use them anyway in the future)&lt;/p&gt;
&lt;p&gt;Check out the &lt;a href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs"&gt;source for List&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Side-note&lt;/strong&gt;: &lt;code&gt;RemoveAt&lt;/code&gt; is more effecient that &lt;code&gt;Remove&lt;/code&gt;. Remove internally performs an &lt;code&gt;IndexOf&lt;/code&gt; followed by a &lt;code&gt;RemoveAt&lt;/code&gt; call itself.&lt;/p&gt;
&lt;h1 id="functions"&gt;Functions&lt;/h1&gt;
&lt;p&gt;So there are...A few of these to cover.
The good news is, I'll mostly be not having to explain them to you.&lt;/p&gt;
&lt;h3 id="constructor"&gt;Constructor&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;static Manager()
{
    Systems = new List&amp;lt;EntitySystem&amp;gt;();
    _entities = new Dictionary&amp;lt;ushort, List&amp;lt;Component&amp;gt;&amp;gt;(); 
    _recycledIds = new Queue&amp;lt;ushort&amp;gt;();
    _lastId = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ah yes, our beloved static constructor. This just instantiates all of our previously explored fields to avoid &lt;del&gt;our fate brought on by Thanos&lt;/del&gt; NullReferenceExceptions &lt;del&gt;caused by Thanos' snapping fingers&lt;/del&gt;.
Wait, what? Don't worry about it. I didn't hear anything.&lt;/p&gt;
&lt;h3 id="creationdeletion-of-entities"&gt;Creation/Deletion of entities&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static ushort CreateEntity()
{
    if (_lastId + 1 &amp;gt;= ushort.MaxValue &amp;amp;&amp;amp; _recycledIds.Count == 0)
    {
        //LOG IT
        _lastId = 0;
    }

    ushort idToUse;
    if (_recycledIds.Count &amp;gt; 0)
    {
        //LOG IT
        idToUse = _recycledIds.Dequeue();
    }
    else
    {
        _lastId++;
        idToUse = _lastId;
    }

    if (_entities.ContainsKey(idToUse))
    {
        _entities[idToUse].Clear();
        foreach (var system in Systems)
        {
            system.EntityDestroyed(entityId);
        }
    }
    else
    {
        _entities.Add(idToUse, new List&amp;lt;Component&amp;gt;(5));
    }
    //LOG IT
    return _lastId;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First of all, you probably didn't come to see the use of my &lt;a href="https://github.com/moolicc/waterlogged"&gt;Logging Library&lt;/a&gt;. Though I supposed there's always a &lt;em&gt;non-zero probability that you did&lt;/em&gt;. But anyway, I just replaced calls to the logging library with a loving comment that yells &amp;quot;LOG IT&amp;quot; at you.&lt;/p&gt;
&lt;p&gt;But onward to the code! And I'm not going to repost it in bits-and-pieces; you'll just have to scroll back up if you forget it.&lt;/p&gt;
&lt;p&gt;Naturally we want to make sure there is an ID available for consumption.
So if we're out of IDs and there are no IDs in our recycle pool, we roll-over our &lt;code&gt;_lastId&lt;/code&gt; to 0.&lt;/p&gt;
&lt;p&gt;Next up, we check our &lt;code&gt;_recycledIds&lt;/code&gt; queue, if it's got something in it, we'll go ahead and pull an ID from there. Otherwise, we just increment &lt;code&gt;_lastId&lt;/code&gt; and use that.&lt;/p&gt;
&lt;p&gt;To cover the event that we may have rolled-back to 0, we want to make sure the &lt;code&gt;_entities&lt;/code&gt; dictionary doesn't already contain our selected ID for our new entity. If it does, no matter; just clear the components list, notify the Systems what happened, and roll with it.
If it doesn't contain our ID and we're genuinely created a new entry, just create a new entry.&lt;/p&gt;
&lt;p&gt;Finally, we return the ID of our new entity to the caller.&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static void DestroyEntity(ushort entityId)
{
    //LOG IT
    foreach (var system in Systems)
    {
        system.EntityDestroyed(entityId);
    }

    _entities.Remove(entityId);
    _recycledIds.Enqueue(entityId);
    //LOG IT
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All we do here is notify each system that we're terrible people and purging an entity and then removing the desired entity.
After that we just mark the entity for recyclation (+1 new coined word) and log a message.&lt;/p&gt;
&lt;h3 id="entityisalive"&gt;EntityIsAlive&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static bool EntityIsAlive(ushort entityId)
{
    return _entities.ContainsKey(entityId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we see one of those that doesn't deserve explanation, nor is it really profound. Yet we'd surely miss it if it wasn't present.&lt;/p&gt;
&lt;h3 id="adding-and-removing-components"&gt;Adding and Removing Components&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static void AddComponent&amp;lt;T&amp;gt;(ushort entityId, T component) where T : Component
{
    if (component.OwnerId != 0)
    {
        //LOG IT AND MAYBE EXCEPTION TOO
        return;
    }
    component.SetOwnerId(entityId);
    _entities[entityId].Add(component);
    ValidifyEntity(entityId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'd say this one is pretty easy to grok also.
We check to ensure the component doesn't have an owning entity already, add the component to the entity, and then notify the systems that the entity was modified.&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static T AddNewComponent&amp;lt;T&amp;gt;(ushort entityId, T component) where T : Component, new()
{
    T value = new T();
    AddComponent(entityId, value);
    return value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is just a convenience function.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Let's kill not two, but three birds with one stone here.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static void RemoveComponent&amp;lt;T&amp;gt;(ushort entityId) where T : Component
{
    for (int i = 0; i &amp;lt; _entities[entityId].Count; i++)
    {
        if (_entities[entityId][i] is T)
        {
            _entities[entityId][i].SetOwnerId(0);
            _entities[entityId].RemoveAt(i);
            ValidifyEntity(entityId);
            return;
        }
    }
    //LOGIT
}

public static void RemoveComponent(ushort entityId, string componentName)
{
    for (int i = 0; i &amp;lt; _entities[entityId].Count; i++)
    {
        if (_entities[entityId][i].ComponentName == componentName)
        {
            _entities[entityId][i].SetOwnerId(0);
            _entities[entityId].RemoveAt(i);
            ValidifyEntity(entityId);
            return;
        }
    }
    //LOGIT
}

public static void RemoveComponent&amp;lt;T&amp;gt;(ushort entityId, T component) where T : Component
{
    if (component.OwnerId != entityId)
    {
        //LOG IT
        return;
    }
    component.SetOwnerId(0);
    _entities[entityId].Remove(component);
    ValidifyEntity(entityId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of the first two do the same thing, with different comparisons.
They iterate over the desired entity's components until they find the one they're looking for. They then remove the component and exit the function, optionally logging it if they don't find what they're looking for.&lt;/p&gt;
&lt;p&gt;The third one is even easier; it just takes in the component the user is trying to remove as a parameter.&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static void ClearComponents(ushort entityId)
{
    //LOG IT

    foreach (var component in _entities[entityId])
    {
        component.SetOwnerId(0);
    }
    
    _entities[entityId].Clear();

    foreach (var system in Systems)
    {
        system.EntityModified(entityId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This guy clears all components from an entity. Not much worth explaining here.&lt;/p&gt;
&lt;h3 id="enumerating-components-contains-functions-and-component-retrieval"&gt;Enumerating Components, Contains Functions, and Component Retrieval&lt;/h3&gt;
&lt;p&gt;All of these probably don't deserve explanation. So I'll just put them here for you to copy + paste or whatever.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static Component[] EnumComponents(ushort entityId)
{
    return _entities[entityId].ToArray();
}

public static T[] EnumComponents&amp;lt;T&amp;gt;(ushort entityId) where T : Component
{
    return _entities[entityId].OfType&amp;lt;T&amp;gt;().ToArray();
}

public static bool ContainsComponent&amp;lt;T&amp;gt;(ushort entityId) where T : Component
{
    return _entities[entityId].Any(c =&amp;gt; c is T);
}

public static bool ContainsComponent(ushort entityId, string componentName)
{
    return _entities[entityId].Any(c =&amp;gt; c.ComponentName == componentName);
}

public static T GetComponent&amp;lt;T&amp;gt;(ushort entityId) where T : Component
{
    return (T)_entities[entityId].FirstOrDefault(c =&amp;gt; c is T);
}

public static T GetComponent&amp;lt;T&amp;gt;(ushort entityId, string componentName) where T : Component
{
    return (T)_entities[entityId].FirstOrDefault(c =&amp;gt; c.ComponentName == componentName);
}

public static Component GetComponent(ushort entityId, Type componentType)
{
    return _entities[entityId].FirstOrDefault(c =&amp;gt; c.GetType() == componentType);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="system-notifications"&gt;System Notifications&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public static void PostMessage(ushort messageId, object data)
{
    PostMessage(new EntityMessage(messageId, data));
}

public static void PostMessage(EntityMessage message)
{
    //LOG ME TOO
    foreach (var system in Systems)
    {
        system.HandleMessage(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All these two blokes do is relay a message to each system.&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private static void ValidifyEntity(ushort entityId)
{
    foreach (var system in Systems)
    {
        system.EntityModified(entityId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This one is similarly straight-forward and simply notifies each system that an entity has been modified in some way. Each system then decides for itself whether or not it is interested in the modified entity.&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Approximately 380 lines later and we have a completed EntityManager.
It's probably been exhausting for you to have to read through it all, as I've not posted a link to the github repo where you can go grab it all without the extraneous fluff of reading a blog. But that's OK. I'm bettering you as a human. With each post you read you shall gain a little bit of patience.&lt;/p&gt;
&lt;p&gt;...Maybe&lt;/p&gt;
</content>
		<summary>&lt;p&gt;The &lt;em&gt;Entity Component System&lt;/em&gt; (We'll abbreviate it &lt;em&gt;ECS&lt;/em&gt; for the sake of brevity) is designed to break away coupling that is naturally introduced when taking advantage of object-oriented-programming.
It achieves this by preferring to create &lt;em&gt;entities&lt;/em&gt; with &lt;strong&gt;composition&lt;/strong&gt; rather than &lt;strong&gt;inheritance&lt;/strong&gt;.
It works by assigning various &lt;em&gt;Components&lt;/em&gt; to each &lt;em&gt;Entity&lt;/em&gt; - such that an entity is nothing more than a container for components - and then various &lt;em&gt;Systems&lt;/em&gt; to act on said components. This in turn, makes the code much easier to maintain and expand upon.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://moolick.dev/blog/entity-component-system-part1</id>
		<title>Creating an Entity Component System in c# - Part 1</title>
		<link href="http://moolick.dev/blog/entity-component-system-part1" />
		<link rel="enclosure" type="image" href="http://moolick.dev/banner.jpg" />
		<updated>2018-05-05T00:00:00Z</updated>
		<content>&lt;aside&gt;
This is a test
&lt;/aside&gt;
&lt;h1 id="the-entity-component-system"&gt;The Entity-Component-System&lt;/h1&gt;
&lt;p&gt;The &lt;em&gt;Entity Component System&lt;/em&gt; (We'll abbreviate it &lt;em&gt;ECS&lt;/em&gt; for the sake of brevity) is designed to break away coupling that is naturally introduced when taking advantage of object-oriented-programming.
It achieves this by preferring to create &lt;em&gt;entities&lt;/em&gt; with &lt;strong&gt;composition&lt;/strong&gt; rather than &lt;strong&gt;inheritance&lt;/strong&gt;.
It works by assigning various &lt;em&gt;Components&lt;/em&gt; to each &lt;em&gt;Entity&lt;/em&gt; - such that an entity is nothing more than a container for components - and then various &lt;em&gt;Systems&lt;/em&gt; to act on said components. This in turn, makes the code much easier to maintain and expand upon.&lt;/p&gt;
&lt;p&gt;Want to add hunger into a survival game?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: add a &lt;em&gt;HungerComponent&lt;/em&gt; and assign it to the entity that represents the player.&lt;/li&gt;
&lt;li&gt;Step 2: add a &lt;em&gt;HungerSystem&lt;/em&gt; which monitors the &lt;em&gt;HungerComponent&lt;/em&gt; and performs whatever actions are necessary and related to hunger. Maybe the system reaches out to a &lt;em&gt;HealthComponent&lt;/em&gt; and depletes health. I don't know.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The beauty of an ECS, in my opinion, is the separation of logic and data it entails. Data is placed in components and logic is placed in systems.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="our-implementation"&gt;Our implementation&lt;/h4&gt;
&lt;p&gt;Our implementation will have various nice little features.
These features include but are not limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Message passing to/from systems.&lt;/li&gt;
&lt;li&gt;Various extensions to increase convenience when working with entities.&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Dynamically loading components at runtime from a csharp-based DSL.&lt;/del&gt;
&lt;em&gt;Scrapped. Prototyped build was cool, but suffered from the performance penalties of Reflection, and compiling c# code. Also it was overall long-winded to write against.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Final phase where we optimize it (it'll need it badly, you'll see).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Let's walk through an example of where an ECS might be beneficial.&lt;/p&gt;
&lt;h2 id="oop-vs-ecs-example"&gt;OOP vs ECS Example*&lt;/h2&gt;
&lt;p&gt;&lt;sub&gt;*: There may be some bias towards the ECS in finding an example, since this post is about ECS.&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;So let's say that you have an &lt;code&gt;Actor&lt;/code&gt; type which represents an NPC in an abstract way.
So maybe you have an &lt;code&gt;EnemyActor&lt;/code&gt; and a &lt;code&gt;DogeActor&lt;/code&gt;, both inheriting our parent &lt;code&gt;Actor&lt;/code&gt; type. But, what would you do if you wanted a bad-guy doge as well?
In a perfect world, you could inherit from both &lt;code&gt;EnemyActor&lt;/code&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;code&gt;DogeActor&lt;/code&gt;, but that creates other issues and isn't actually possible as far as csharp's compiler is concerned anyway.&lt;/p&gt;
&lt;p&gt;&lt;img src="/resources/blog/entity-component-system-part1/oop-problem.png" class="img-fluid" alt="oop-problem" /&gt;&lt;/p&gt;
&lt;p&gt;&amp;quot;OK&amp;quot;, you might think to yourself, you optimistic human you. Copy + Paste the code from both &lt;code&gt;EnemyActor&lt;/code&gt; and &lt;code&gt;DogeActor&lt;/code&gt; into a new &lt;code&gt;EnemyDogeActor&lt;/code&gt; type. Well guess what. That's code duplication and it's not really a great thing to deal with. What happens when you change the behavior of an enemy? Now you've got to modify the behavior logic in &lt;strong&gt;two&lt;/strong&gt; places. Both &lt;code&gt;EnemyActor&lt;/code&gt; and &lt;code&gt;EnemyDogeActor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And you can't really inherit from just one of them and copy + paste the other into the new type, either. That won't work because then you'd have the behavior of a friendly, happy doggo when he's supposed to be snarling away at you with foam secreting from his mouth.&lt;/p&gt;
&lt;p&gt;Don't take my word for it though, Robert C. Martin vents/rants about code duplication in probably every one of his books (great books by the way, you should give them a read if you haven't yet.)&lt;/p&gt;
&lt;h1 id="implementation"&gt;Implementation&lt;/h1&gt;
&lt;p&gt;Let's start off with a skeleton from which we can work in future posts.&lt;/p&gt;
&lt;h2 id="entitymanager.cs"&gt;EntityManager.cs&lt;/h2&gt;
&lt;p&gt;The EntityManager is responsible for storing the entities and their components.
It should contain functions to act on the components each entity owns. Additionally, it'll have a messaging feature that systems can use to talk to each other without directly coupling together.&lt;/p&gt;
&lt;p&gt;So, here's a bare-bones shell:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;using System;
using System.Collections.Generic;
using System.Linq;

namespace GoldRush.Ecs
{
    static class Manager
    {
        static Manager()
        {
        }

        public static ushort CreateEntity()
        {
        }

        public static void DestroyEntity(ushort entityId)
        {
        }

        public static bool EntityIsAlive(ushort entityId)
        {
            return false;
        }

        public static T AddNewComponent&amp;lt;T&amp;gt;(ushort entityId, T component) where T : Component, new()
        {
            return new(T)
        }

        public static void AddComponent&amp;lt;T&amp;gt;(ushort entityId, T component) where T : Component
        {
        }

        public static void RemoveComponent&amp;lt;T&amp;gt;(ushort entityId) where T : Component
        {
        }

        public static void RemoveComponent(ushort entityId, string componentName)
        {
        }

        public static void RemoveComponent&amp;lt;T&amp;gt;(ushort entityId, T component) where T : Component
        {
        }
        
        public static void ClearComponents(ushort entityId)
        {
        }

        public static Component[] EnumComponents(ushort entityId)
        {
            return new Component[0];
        }

        public static T[] EnumComponents&amp;lt;T&amp;gt;(ushort entityId) where T : Component
        {
            return new T[0];
        }

        public static bool ContainsComponent&amp;lt;T&amp;gt;(ushort entityId) where T : Component
        {
            return false;
        }

        public static bool ContainsComponent(ushort entityId, string componentName)
        {
            return false;
        }

        public static T GetComponent&amp;lt;T&amp;gt;(ushort entityId) where T : Component
        {
            return default(T);
        }

        public static T GetComponent&amp;lt;T&amp;gt;(ushort entityId, string componentName) where T : Component
        {
            return default(T);
        }

        public static Component GetComponent(ushort entityId, Type componentType)
        {
            return null;
        }

        public static void PostMessage(ushort messageId, object data)
        {
        }

        public static void PostMessage(EntityMessage message)
        {
        }

        private static void ValidifyEntity(ushort entityId)
        {
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There we go! That'll be a nice canvas we can play with.&lt;/p&gt;
&lt;h2 id="system.cs"&gt;System.cs&lt;/h2&gt;
&lt;p&gt;I'm actually going to go ahead and supply the entire code for this one. It's extremely simple.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;using System.Collections.Generic;

namespace Ecs
{
    abstract class System
    {
        protected List&amp;lt;ushort&amp;gt; _validEntites;

        protected System()
        {
            _validEntites = new List&amp;lt;ushort&amp;gt;();
        }

        public void EntityModified(ushort entityId)
        {
            bool valid = EntityValid(entityId);
            bool wasValid = _validEntites.Contains(entityId);
            
            if (valid &amp;amp;&amp;amp; !wasValid)
            {
                _validEntites.Add(entityId);
            }
            if (!valid &amp;amp;&amp;amp; wasValid)
            {
                _validEntites.Remove(entityId);
            }
        }

        public void EntityDestroyed(ushort entityId)
        {
            if (_validEntites.Contains(entityId))
            {
                _validEntites.Remove(entityId);
            }
        }

        public virtual void HandleMessage(EntityMessage message)
        {
        }

        protected abstract bool EntityValid(ushort entityId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we have various functions that our EntityManager will call into.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EntityModified&lt;/code&gt; gets called whenever an entity's composition gets changed. Either by way of adding components to or removing components. This then throws all &amp;quot;valid&amp;quot; entities (by their IDs) into a list that subclasses can take a look at.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EntityDestroyed&lt;/code&gt; ahem, this is called whenever we delete an entity.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HandleMessage&lt;/code&gt; right, so, this is called whenever another system calls the EntityManager's &lt;code&gt;PostMessage&lt;/code&gt; function. Most systems will probably not care about any messages, so we'll leave this function virtual.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EntityValid&lt;/code&gt; is for subclasses to let us know if a given entity has the component make-up that this system cares about.&lt;/p&gt;
&lt;h2 id="component.cs"&gt;Component.cs&lt;/h2&gt;
&lt;p&gt;Our Component base is even better.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;namespace Ecs
{
    public abstract class Component
    {
        public ushort OwnerId { get; private set; }

        public virtual string ComponentName =&amp;gt; this.GetType().Name;

        public void SetOwnerId(ushort newOwner)
        {
            OwnerId = newOwner;
        }
        
        public virtual Component Set(string property, object value)
        {
            return this;
        }

        public virtual T Get&amp;lt;T&amp;gt;(string property)
        {
            return default(T);
        }

        public virtual object Get(string property)
        {
            return null;
        }

        public abstract bool CanSerialize { get; }

        public abstract void Deserialize(byte[] data);
        public abstract byte[] Serialize();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only things in this type that might requiring explaining would be the &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Get&lt;/code&gt; functions. These will be used and explained later on, I promise.&lt;/p&gt;
&lt;h2 id="entitymessage.cs"&gt;EntityMessage.cs&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;namespace Ecs
{
    class EntityMessage
    {
        public ushort MessageId { get; private set; }
        public object Data { get; private set; }

        public EntityMessage(ushort messageId)
            : this(messageId, null)
        {

        }

        public EntityMessage(ushort messageId, object data)
        {
            MessageId = messageId;
            Data = data;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...&lt;em&gt;I'm not even going to actually explain this to you&lt;/em&gt;... But it could maybe become a struct if you wanted it to.&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Thus we have completed the first leg of our trip.
We've covered enough to keep the compiler from crying to you, and probably enough for you to finish it yourself at this point.&lt;/p&gt;
&lt;p&gt;Though I shall not falter; But I will post probably two more posts on this subject. I'm thinking one where we finish the EntityManager and another where we write in dynamic, runtime-loading, really cool, components that are defined in a C# DSL we'll implement with Roslyn's scripting API *.&lt;/p&gt;
&lt;p&gt;*: That was scrapped.&lt;/p&gt;
&lt;p&gt;Oh, and then maybe another post where we tie it all up in an example.
So I guess that's three more posts.&lt;/p&gt;
&lt;p&gt;As an excersise, why not replace everything applicable with &lt;code&gt;structs&lt;/code&gt; and use &lt;code&gt;ref&lt;/code&gt; everywhere to reduce heap allocations. It might be interesting to compare the performance of both an implementation passing references to Stack values around and an implementation that just uses Heap (allocations and) references. Then one could decided on a case-by-case basis which would be better for each project, given how much data you play around with.&lt;/p&gt;
&lt;p&gt;You should also check out the &lt;a href="http://gameprogrammingpatterns.com/component.html"&gt;The ECS's entry&lt;/a&gt; in the free online book, &lt;a href="http://gameprogrammingpatterns.com"&gt;&lt;strong&gt;GameProgrammingPatterns&lt;/strong&gt; by &lt;em&gt;Robert Nystrom&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>&lt;p&gt;The &lt;em&gt;Entity Component System&lt;/em&gt; (We'll abbreviate it &lt;em&gt;ECS&lt;/em&gt; for the sake of brevity) is designed to break away coupling that is naturally introduced when taking advantage of object-oriented-programming.
It achieves this by preferring to create &lt;em&gt;entities&lt;/em&gt; with &lt;strong&gt;composition&lt;/strong&gt; rather than &lt;strong&gt;inheritance&lt;/strong&gt;.
It works by assigning various &lt;em&gt;Components&lt;/em&gt; to each &lt;em&gt;Entity&lt;/em&gt; - such that an entity is nothing more than a container for components - and then various &lt;em&gt;Systems&lt;/em&gt; to act on said components. This in turn, makes the code much easier to maintain and expand upon.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://moolick.dev/blog/first-post</id>
		<title>First Post</title>
		<link href="http://moolick.dev/blog/first-post" />
		<link rel="enclosure" type="image" href="http://moolick.dev/banner.jpg" />
		<updated>2018-04-16T00:00:00Z</updated>
		<content>&lt;p&gt;This is my first post!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;static int Main(string[] args)
{
    Console.WriteLine(&amp;quot;Hello, World!&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;fn main() {
    println!(&amp;quot;Hello, World!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;open System

[&amp;lt;EntryPoint&amp;gt;]
let main argv = 
    printfn &amp;quot;Hello, World!&amp;quot; 
    Console.ReadLine() |&amp;gt; ignore
    0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Currently playing around with the &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt; static site generator.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;This is my first post!&lt;/p&gt;</summary>
	</entry>
</feed>