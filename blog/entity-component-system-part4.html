
<!DOCTYPE html>
<html lang="en">
        <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>

        <title>Moolick&#x27;s Writings - Creating an Entity Component System in c# - Revisit</title>
        <meta name="description" content="Moolick&#x27;s Writings" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">        

        <link type="application/rss+xml" rel="alternate" title="Moolick&#x27;s Writings" href="/feed.rss" />
                <link type="application/atom+xml" rel="alternate" title="Moolick&#x27;s Writings" href="/feed.atom" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">

        <link href="/assets/css/bootstrap.min.css" rel="stylesheet" />
        <link href="/assets/css/highlight.css" rel="stylesheet">
        <link href="/assets/css/clean-blog.css" rel="stylesheet" />
        <link href="/assets/css/master.css" rel="stylesheet" />
        <link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
        <link href="/assets/css/override.css" rel="stylesheet" />


        <meta name="application-name" content="Moolick&#x27;s Writings" />
        <meta name="msapplication-tooltip" content="Moolick&#x27;s Writings" />
        <meta name="msapplication-starturl" content="/" />

        <meta property="og:title" content="Moolick&#x27;s Writings - Creating an Entity Component System in c# - Revisit" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="http://moolick.dev/blog/entity-component-system-part4" />
        <!-- TODO: More social graph meta tags -->

        


        </head>
        <body>
                
                <!-- Navigation -->
                <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
                        <div class="container-fluid">
                                <!-- Brand and toggle get grouped for better mobile display -->
                                <div class="navbar-header page-scroll">
                                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
                                        <span class="sr-only">Toggle navigation</span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        </button>
                                        <a class="navbar-brand" href="/">Moolick&#x27;s Writings</a>
                                </div>
                        
                                <!-- Collect the nav links, forms, and other content for toggling -->
                                <div class="collapse navbar-collapse" id="navbar-collapse">
                                        <ul class="nav navbar-nav navbar-right">
                                                <li><a href="/about">About</a></li>
<li><a href="/contact">Contact</a></li>
<li><a href="/blog">Archive</a></li>
<li><a href="/tags">Tags</a></li> 
                                        </ul>
                                </div>
                                <!-- /.navbar-collapse -->
                        </div>
                        <!-- /.container -->
                </nav>
                
                <!-- Page Header -->
                <header class="intro-header" id="intro-header" style="background-image: url(&quot;/banner.jpg&quot;)">
                        <div class="container">
                                <div class="row">
                                        <div class="col-md-12">

    
<div class="post-heading">
    <h1>Creating an Entity Component System in c# - Revisit</h1>
        <h2 class="subheading">We shall explore the creation and usage of an Entity-Component-System in a couple posts.&#xA;In this post, we&#x27;ll throw all the previous posts away and actually write an ECS skeleton.&#xA;</h2>
    <div class="meta">        
Published on Saturday, January 12, 2019<br>    </div>
        <div class="tags">
                    <a role="button" href="/tags/C%23" class="btn btn-default btn-xs">C#</a>
                    <a role="button" href="/tags/Design-Pattern" class="btn btn-default btn-xs">Design Pattern</a>
                    <a role="button" href="/tags/Game-Development" class="btn btn-default btn-xs">Game Development</a>
                    <a role="button" href="/tags/MonoGame" class="btn btn-default btn-xs">MonoGame</a>
        </div>     
</div>
                                        </div>
                                </div>
                        </div>
                </header>
                
                <!-- Main Content -->
                <div class="container">
                        <div class="row">
                                <div id="content" class="col-md-12">
                                        

<h1 id="revisit">Revisit</h1>
<p>Clear your mind of what you've read here from previous posts in this overly long-winded series.
Shortly after I wrote the last post, I realized that some of the stuff I said was not entirely correct.
Specifically, we were still stacking up the HEAP allocations because</p>
<ol type="A">
<li>Value-type implementations of interfaces are boxed</li>
<li>an <code>int</code> stored as an <code>object</code> is boxed</li>
</ol>
<p>However, We'll still follow the same concept for data locality. We'll use a 1-dimensional array to store entities via their IDs and components.
We'll use the fore-front of our array to index into entities' components.
A key difference, is that this time, our list's declaration looks like <code>List&lt;EntityItem&gt; _entities;</code>.
This brings us to our first point.</p>
<h2 id="terminology-ill-try-to-follow">Terminology I'll (try) to follow</h2>
<p>Let's just go over the wording I'll use to make sure everything I type here is crystal-clear.</p>
<ul>
<li>An <em>entity index</em> or <em>entity pointer</em> is the item within our entities list that holds an index to the beginning of an entity's component list</li>
<li>An <em>entity ID</em> is an index that corresponds to an entity index within the entities list</li>
<li>An <em>entity</em> is the sub-list of components within our entities list that represents an entity in the caller's game or simulation.</li>
</ul>
<p>Here's a little something I drew-up to hopefully help visualize. It also might be too hard to see, I'm one of the unlucky folks who doesn't have 20 cameras
on my phone to take clear pictures.
Where <em>E</em> is our list of entities.</p>
<p><img src="/assets/blog/entity-component-system-part4/ecs.jpg" class="img-fluid" alt="rough-ecs" /></p>
<p>Note that the code itself might not fully conform to these terms. Hopefully, it'll be concise enough to not even matter though.</p>
<h1 id="storing-numerical-ids-without-boxing">Storing Numerical IDs Without Boxing</h1>
<p>OK, so the title of this paragraph is a tad misleading. We'll in actuality be abstracting both entity indices and components, but this time we'll do so
via our own struct, which I've aptly named <code>EntityItem</code>. However at least here, we know our 32-bit integer ID won't be stored in the HEAP.</p>
<p>An instance of an EntityItem either represents an entity's index or an actual concrete component.
The EntityItem type contains most importantly, two fields. One of type ComponentBase (named &quot;Component&quot;), and another of type int (named &quot;EntityIndex&quot;). We've also got a bool for IsAlive to determine if the entity has been removed or not. And finally, I've thrown in a handy bool, <em>IsComponent</em>.</p>
<p>It's probably worth noting that all of these are literally <strong>fields</strong> and not <strong>properties.</strong>. The purpose of this
is that fields are stored as <em>references</em> and properties behave more like <em>values</em> (properties are a tad more complicated than that as they really
just wrap around private fields themselves anyway). This is important because if our Component field was accessed like a value, then changes made to
the component in the code that consumes are ECS wouldn't modify the actual component we're storing, but in essence a copy of it.
Additionally, I've thrown in a couple of constructor overloads to make instantiating this struct more convinient.
<code>public EntityItem(int entityIndex)</code> and <code>public EntityItem(ComponentBase component)</code>. Though both of these just call into an
private constructor that looks like <code>private EntityItem(int entityIndex, ComponentBase component)</code> that sets everything up for us.</p>
<h1 id="the-entity-manager">The Entity Manager</h1>
<p>Our entity manager is very similar to the previous idea, having a single list containing components bound to numerical entity IDs.
Also like I mentioned in the previous post, we'll set our list's initial capacity to go ahead and have its internal array allocate a chunk of memory.
If we don't do this, then as we add to the list it'll contantly have to resize its underlying array.
In fact, the contructor's body is only three lines, and is responsible only for creating a list of systems to manager, our entity list,
and setting our entity ID counter to 0. It looks a little something like this</p>
<pre><code class="language-cs">public EntityManager(int entityCount)
{
  Systems = new List&lt;SystemBase&gt;();
  _entities = new List&lt;EntityItem&gt;(entityCount * COMPONENTS_PER_ENTITY);
  _deadIds = new Queue&lt;int&gt;(entityCount);
  _nextId = 0;
}
</code></pre>
<p><code>COMPONENTS_PER_ENTITY</code> is merely an estimated number of components every entity will contain. At the time of writing this, it's set to 6.</p>
<h2 id="the-code">The Code</h2>
<p>I'll try to keep some of my breath in my lungs and only mention the interesting/important bits in here, but I'll leave a link to the code further on.
Certainly most of the code is boilerplate, and there's a lot of duplication because within the (dare I call them) algorithms I use in each operation
(remove, add, find, etc) there are small changes on singular lines to optimize for that specific operation we're performing at the time.</p>
<p>OK, let's begin.</p>
<h3 id="private-utilities">Private utilities</h3>
<p>One thing we'll be doing a lot of is identifying if an <em>EntityItem</em> at a given index within <em>_entites</em> is an entity or a component.
That being said, we can save some time and ware on our fingers if we use a helper function, like the following</p>
<pre><code class="language-cs">private bool IsEntityPointer(int entityId, out EntityItem entityItem)
{
  entityItem = EntityItem.Empty;
  if (entityId &lt; 0
      || entityId &gt;= _entities.Count
      || _entities[entityId].IsComponent)
  {
      return false;
  }

  entityItem = _entities[entityId];
  return true;
}
</code></pre>
<p>What we're doing here, is merely checking the given index to ensure it is within our <em>_entites</em> bounds and then checking the item at that index
to see if it's an entity index or entity. We also go ahead and return the entityitem (assuming it was an entity index) in the form of our <code>out EntityItem entityItem</code>.</p>
<p>Furthermore, we'll be performing quite a few operations upon entity pointers, so let's go ahead and create a helper function to aid with that.</p>
<pre><code class="language-cs">private void IterateEntityPointers(int startingId, Action&lt;int, EntityItem&gt; action)
{
  for (int i = startingId; i &lt; _entities.Count &amp;&amp; IsEntityPointer(i, out var item); i++)
  {
      action(i, item);
  }
}
</code></pre>
<p>This will allow us to loop over entity pointers without throwing the exact same for loop everywhere. It's important to note
that this loop stops iterating as soon as we hit an entity's component list.</p>
<p>I think this is best explained through an example of use, so here goes</p>
<pre><code class="language-cs">IterateEntityPointers(0, (i, e) =&gt;
  {
    Console.WriteLine($&quot;Entity at ID {i}: {e}&quot;);
  });
</code></pre>
<p>Similarly, we also have one to iterate over an entire entity.</p>
<pre><code class="language-cs">private void IterateEntity(EntityItem entity, int entityId, Func&lt;int, EntityItem, bool&gt; action)
{
  int endIndex = _entities.Count;
  if(IsEntityPointer(entityId + 1, out var nextEnt))
  {
    endIndex = nextEnt.EntityIndex;
  }
  for (int i = entity.EntityIndex; i &lt; endIndex; i++)
  {
    if(action(i, _entities[i]))
    {
      break;
    }
  }
}
</code></pre>
<p>We also throw in the necessary logic to ensure we don't overflow into another entity (<em>see: endIndex</em>).
This one is a tad bit different than the former in that it allows the calling code to break out of the loop early if <code>action</code> returns <em>true</em>.</p>
<h3 id="public-appearances">Public appearances</h3>
<p>Now that we've got all of our little helpers out of the way, let's go ahead and cover the 6 basic operations a caller might do</p>
<ol>
<li>Creating an entity</li>
<li>Destroying an entity</li>
<li>Adding a component to an entity</li>
<li>Removing a component from an entity</li>
<li>Checking for the existance of a component within an entity</li>
<li>Iterating an entity's components</li>
</ol>
<p>Without too much fanfaire, I'm just going to give you a good shove off the proverbial diving board.</p>
<h4 id="creating-an-entity">Creating an entity</h4>
<p>First, it's rather important to have to ability to add an entity to our thing here.
We'll do that via a fancy, albeit blandly named <em>CreateEntity</em> function.</p>
<pre><code class="language-cs">public int CreateEntity()
{
  //Check for a recyclable ID first.
  if(_deadIds.Count != 0)
  {
    int id = _deadIds.Dequeue();
    var ent = _entities[id];
    ent.IsAlive = true;
    _entities[id] = ent;
    return id;
  }

  //Increment each previous entity's starting index.
  for (int i = 0; i &lt; _nextId; i++)
  {
    var ent = _entities[i];
    ent.EntityIndex++;
    _entities[i] = ent;
  }
  //Add this entity in with a starting index pointing to the end
  //of the array.
  _entities.Insert(_nextId, new EntityItem(_entities.Count + 1));
  return _nextId++;
}
</code></pre>
<p>The comments hopefully make this snippet self-explanatory, but I'll show you the highlights anyway.
First of all, we quite simply check for dead entities to revive for use. But if there's not an entity we can breath life into again, we have
to take a few precautions to add a new entity pointer.
So if we're going to be adding in an entity pointer <strong>after</strong> other entity pointers but <strong>before</strong> entities actually begin then it's pretty
important to inform the previous entity pointers that we're going to do this. Otherwise, their indices won't be correct as our list will grow
without them being aware. <em>We'll unfortunately have to do this until the machine learning train creates self-aware objects.</em></p>
<h4 id="destroying-an-entity">Destroying an entity</h4>
<p>Next up, we should take a look at the case where a caller might be a monster and desire the destruction of an entity.
So I guess we should also include a method of the removal of entities.</p>
<aside>Remember, Simba</aside>
<p>\</p>
<blockquote class="blockquote">
<p>: I actually forgot to implement this until writing this post. Before this time, entities overpopulated the world, causing mass-chaos.</p>
</blockquote>
<pre><code class="language-cs">public void DestroyEntity(int entityId)
{
  //Sanity check to make sure the passed entityId is valid.
  if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
  {
    throw new InvalidOperationException(&quot;The specified entity does not exist.&quot;);
  }

  //Find the end index of the entity's component list.
  int endIndex = _entities.Count;
  if(IsEntityPointer(entityId + 1, out var nextEntityItem))
  {
    endIndex = nextEntityItem.EntityIndex;
  }

  //Hold the actual number of components this entity owns.
  int componentCount = endIndex - entItem.EntityIndex;

  //Decrement all following entity pointers to account for the removal
  //of the components from the current entity.
  IterateEntityPointers(entityId + 1, (i, e) =&gt;
    {
      e.EntityIndex -= componentCount;
      _entities[i] = e;
    });

  //Remove the entity and mark the pointer as dead.
  _entities.RemoveRange(entItem.EntityIndex, componentCount);
  entItem.IsAlive = false;
  _entities[entityId] = entItem;
  _deadIds.Enqueue(entityId);
}
</code></pre>
<p>OK, that one is a tad bit longer than we're used to. But we'll be fine if we break it down.
First, as the comment states, we perform a check to ensure the entity is currently alive and well.
We'll see checks like these throughout, so I'll probably not explain them going on.</p>
<p>The next thing we do is find out where this entity ends, we do this to find the count of components this entity contains.
We then inform all following entities about the removal of our components. If we don't do this, other entities won't know
that the indices in the list are changing and we could (and would) have descprepancies.</p>
<p>Finally, we simply remove the components and mark the entity ID as dead.</p>
<h4 id="adding-a-component-to-an-entity">Adding a component to an entity</h4>
<p>Now that we know how to add and remove entire entities, what's say we go ahead and look at the code we use to add a component
to an entity. It's worth noting that this doesn't <em>add</em> a component to the end of an entity, but rather this will <em>push</em> a component
into the first position of an entity.</p>
<pre><code class="language-cs">public void PushComponent(int entityId, ComponentBase component)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&quot;The specified entity does not exist.&quot;);
    }

    //If there are entities after this one, increment their starting indices.
    IterateEntityPointers(entityId + 1, (i, e) =&gt;
    {
        e.EntityIndex++;
        _entities[i] = e;
    });

    //Add the component under the entity's area.
    component.OwnerId = entityId;
    _entities.Insert(entItem.EntityIndex, new EntityItem(component));

    //Notify the systems that an entity has been modified.
    RefreshSystems(entityId);
}
</code></pre>
<p>This code should be fairly self-explanatory.
The first interesting thing we do is notify following entity pointers that they should increment by one to account for the new component going in
ahead of their entities.
Second, we set the component's owner and add it in.
Finally, we inform all systems that an entity has been modified.</p>
<h4 id="removing-a-component">Removing a component</h4>
<p>The removal of a component is exactly the same as the addition of a component, but of course in reverse.</p>
<pre><code class="language-cs">public void RemoveComponent(int entityId, ComponentBase component)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&quot;The specified entity does not exist.&quot;);
    }

    //Find the index of the component.
    int componentIndex = -1;
    IterateEntity(entItem, entityId, (i, c) =&gt;
    {
        if(c.Component == component)
        {
            c.Component.OwnerId = -1;
            componentIndex = i;
            return true;
        }
        return false;
    });
    
    //Sanity check to make sure the component exists.
    if(componentIndex == -1)
    {
        throw new InvalidOperationException(&quot;The specified entity does not contain that component.&quot;);
    }

    //If there are entities after this one, decrement their starting indices.
    IterateEntityPointers(entityId + 1, (i, e) =&gt;
    {
        e.EntityIndex--;
        _entities[i] = e;
    });

    //Remove the component
    _entities.RemoveAt(componentIndex);

    //Notify the systems that an entity has been modified.
    RefreshSystems(entityId);
}
</code></pre>
<p>The first thing worth mentioning that we're doing here is finding out where the component actually lives in the larget _entities list.
While we're at that search, we go ahead and set the component's owner to -1 to signify that it's no longer loved enough to have an owner.</p>
<p>The next thing we do - and this is a bit complicated so please, try to stay with me - the next thing we do is an error check to
ensure that the component was actually found.</p>
<p>Finally, we once again inform other entity pointers about this change, remove the component, and notify systems there's been a modification
to our entity.</p>
<h4 id="checking-for-the-extistance-of-a-component">Checking for the extistance of a component</h4>
<p>Honestly I'm not even sure I can fluff this up a great deal. It's really quite simple and the code is mostly self-explanatory.
But I'd say I'm doing a fantastic job of jamming as many characters as I can into this section before even showing you the code.</p>
<p>Without further ado, I will not copy + past the code into this document for your viewing.</p>
<pre><code class="language-cs">public bool ContainsComponent(int entityId, ComponentBase component)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&quot;The specified entity does not exist.&quot;);
    }

    //Check if the component exists.
    bool foundComponent = false;
    IterateEntity(entItem, entityId, (i, c) =&gt;
    {
        if (c.Component == component)
        {
            foundComponent = true;
            //return true to inform IterateEntity to stop iterating.
            return true;
        }
        return false;
    });

    //Return the results.
    return foundComponent;
}
</code></pre>
<h4 id="iterating-over-an-entitys-components">Iterating over an entity's components</h4>
<p>...I won't even try for this one...</p>
<pre><code class="language-cs">public IEnumerable&lt;ComponentBase&gt; GetComponents(int entityId)
{
    //Sanity check to make sure the passed entityId is valid.
    if (!IsEntityPointer(entityId, out var entItem) || !entItem.IsAlive)
    {
        throw new InvalidOperationException(&quot;The specified entity does not exist.&quot;);
    }

    //Iterate until necessary and yield return the components.
    int endIndex = _entities.Count;
    if (IsEntityPointer(entityId + 1, out var nextEnt))
    {
        endIndex = nextEnt.EntityIndex;
    }
    for (int i = entItem.EntityIndex; i &lt; endIndex; i++)
    {
        yield return _entities[i].Component;
    }
}
</code></pre>
<p>The only thing here to note is the <code>yield</code> statement. If you're not sure what that means, then honestly google it.
There are plenty of smarter people who are far better at explaining things than me that have written about it.
Besides, probably the best advice you can garner from the internet is actually how to google.</p>
<h3 id="other-code">Other code</h3>
<p>There's plenty of other code you can poke around at in the github.
I've included plenty of overloads to make the life of a consumer of this API easy and painless.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Whew! After nearly a year, I've finally gotten around to completing an ECS and writing about it.
The Entity Component System is a fantastic tool to have on your belt, and honestly it's a joy to work with.
Writing one up can be kind of boiler-plate, but I find it fun to try and make it unique and at least some-what performance friendly.</p>
<p>I've thrown the full code up on my <a href="https://github.com/jmikew/hourglass">github</a>.
So please, go poke around, have some fun, and let me know how it goes!</p>



                                </div>
                        </div>
                </div>
                
                <hr>
                
                <!-- Footer -->
                <footer>
                        <div class="container">
        <div class="row">
                <div class="col-md-12">
                <ul class="list-inline text-center">
                        <li>
                        <!--
                        <a href="">
                                <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                        -->
                        <a onclick="alert('I no longer use Twitter :(')">
                                <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                        </li>
                        <li>
                        <a href="https://github.com/moolicc">
                                <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                        </li>
                </ul>
                <p class="copyright text-muted">
                        Copyright © 2020 by Moolick.
                        <br />
                        <a href="/feed.rss"><i class="fa fa-rss"></i> RSS Feed</a> | <a href="/feed.atom"><i class="fa fa-rss"></i> Atom Feed</a>
                        <br />
                        
                        <strong><i><a href="https://wyam.io">Generated by Wyam</a></i></strong>
                </p>
                </div>
        </div>
</div>
                </footer> 

                <script src="/assets/js/jquery.min.js"></script>
                <script src="/assets/js/bootstrap.min.js"></script>     
                <script src="/assets/js/highlight.pack.js"></script>   
                <script src="/assets/js/clean-blog.js"></script>
                <script src="/assets/js/d3.v3.min.js"></script>
                <script src="/assets/js/trianglify.min.js"></script>
                <script src="/assets/js/Please-compressed.js"></script>
                <script src="/assets/js/background-check.min.js"></script>

                <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
                <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
                <!--[if lt IE 9]>
                        <script src="/assets/js/html5shiv.js"></script>
                        <script src="/assets/js/respond.min.js"></script>
                <![endif]-->
                
                <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111568751-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111568751-1');
</script>

                <script>hljs.initHighlightingOnLoad();</script>


                <script>
                        BackgroundCheck.init({
                                targets: '.intro-header,.navbar',
                                images: '.intro-header'
                        });
                </script>
        </body>
</html>

